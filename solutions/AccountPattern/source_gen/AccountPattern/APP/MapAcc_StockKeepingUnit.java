package AccountPattern.APP;

/*Generated by MPS */

import org.modellwerkstatt.manmap.solution.manmapRT.IM3ClassMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.modellwerkstatt.manmap.solution.manmapRT.MMJodaDateTimeTypeHanlder;
import org.modellwerkstatt.manmap.solution.manmapRT.MMJodaLocalDateTypeHanlder;
import org.modellwerkstatt.manmap.solution.manmapRT.MMBigDecimalTypeHandler;
import org.modellwerkstatt.manmap.solution.manmapRT.MMStringTypeHandler;
import org.modellwerkstatt.manmap.solution.manmapRT.MMIntTypeHandler;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import java.sql.ResultSet;
import java.sql.SQLException;
import javax.sql.DataSource;
import org.modellwerkstatt.manmap.solution.manmapRT.IM3ManMapSession;
import org.springframework.dao.DataAccessException;
import org.springframework.jdbc.core.PreparedStatementSetter;
import java.sql.PreparedStatement;
import org.springframework.jdbc.IncorrectResultSetColumnCountException;
import org.modellwerkstatt.manmap.solution.manmapRT.M3ObjectKeyStore;
import java.util.List;
import org.springframework.jdbc.core.ResultSetExtractor;
import org.springframework.jdbc.core.PreparedStatementCreator;
import java.sql.Connection;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import org.joda.time.DateTime;
import org.joda.time.LocalDate;
import java.math.BigDecimal;

public class MapAcc_StockKeepingUnit implements IM3ClassMapper<Acc_StockKeepingUnit, Integer> {
  public static final int entitySessionUID = Acc_StockKeepingUnit.entitySessionUID;

  @Autowired
  private MMJodaDateTimeTypeHanlder _dateTimeTypeHandler;
  @Autowired
  private MMJodaLocalDateTypeHanlder _localDateTypeHandler;
  @Autowired
  private MMBigDecimalTypeHandler _bigDecimalTypeHandler;
  @Autowired
  private MMStringTypeHandler _stringTypeHandler;
  @Autowired
  private MMIntTypeHandler _intTypeHandler;

  private final int[] keysIndex = new int[]{0};
  private JdbcTemplate jdbcTemplate;
  private RowMapper getRowMapper = new RowMapper<Acc_StockKeepingUnit>() {
    public Acc_StockKeepingUnit mapRow(ResultSet p0, int p1) throws SQLException {
      return MapAcc_StockKeepingUnit.this.map(p0, 1);
    }
  };

  @Autowired
  public MapAcc_StockKeepingUnit(DataSource dataSrouce) {
    this.jdbcTemplate = new JdbcTemplate(dataSrouce);

  }

  public MapAcc_StockKeepingUnit() {
  }

  public String getEntityFQName() {
    return "AccountPattern.APP.Acc_StockKeepingUnit";
  }

  public void setDataSource(DataSource dataSource) {
    // DEBUG - when not autowired .. manual init without runtime 
    System.err.println("AccountPattern.APP.MapAcc_StockKeepingUnit: You are using a debug configuration. (i.e. setDataSource() was called)");
    _dateTimeTypeHandler = new MMJodaDateTimeTypeHanlder();
    _localDateTypeHandler = new MMJodaLocalDateTypeHanlder();
    _bigDecimalTypeHandler = new MMBigDecimalTypeHandler();
    _stringTypeHandler = new MMStringTypeHandler();
    _intTypeHandler = new MMIntTypeHandler();
    this.jdbcTemplate = new JdbcTemplate(dataSource);
  }






  public Acc_StockKeepingUnit map(ResultSet resultSet, int curCol) throws SQLException {
    Acc_StockKeepingUnit acc_stockkeepingunit_2 = new Acc_StockKeepingUnit();

    acc_stockkeepingunit_2.setId(_intTypeHandler.getResult(resultSet, curCol++));
    acc_stockkeepingunit_2.setFiliale(_stringTypeHandler.getResult(resultSet, curCol++));
    acc_stockkeepingunit_2.setArtikel(_stringTypeHandler.getResult(resultSet, curCol++));

    // TCN enabled ?  

    return acc_stockkeepingunit_2;
  }




  public Acc_StockKeepingUnit map(ResultSet resultSet, int curCol, Acc_StockKeepingUnit existingEntity) throws SQLException {
    Acc_StockKeepingUnit acc_stockkeepingunit_2 = existingEntity;

    acc_stockkeepingunit_2.setId(_intTypeHandler.getResult(resultSet, curCol++));
    acc_stockkeepingunit_2.setFiliale(_stringTypeHandler.getResult(resultSet, curCol++));
    acc_stockkeepingunit_2.setArtikel(_stringTypeHandler.getResult(resultSet, curCol++));

    // TCN enabled ?  

    return acc_stockkeepingunit_2;
  }




  public Integer getKey(ResultSet resultSet, int startRow) throws SQLException {
    int key;

    // returns null, if key is not set, e.g. key is 0 or string is "" 
    key = _intTypeHandler.getResult(resultSet, startRow + keysIndex[0]);
    if (_intTypeHandler.isNullRef(key)) {
      return null;
    }
    return key;
  }




  public String fieldsForSelect(boolean rootTable) {
    if (rootTable) {
      return "iRoot.ID, iRoot.FILIALE, iRoot.ARTIKEL";
    } else {
      return "iRoot.ID, iRoot.FILIALE, iRoot.ARTIKEL";
    }
  }



  public String getCurrentTableName(IM3ManMapSession session) {
    String tableName = "ACC_STOCK_KEEPING_UNIT";


    return tableName;
  }






  public void update(final Acc_StockKeepingUnit entity, final IM3ManMapSession session, boolean audit) throws DataAccessException {

    if (entity.getReadOnly()) {
      throw new IllegalStateException("Update called on entity which was marked as readonly. (key " + entity.getKey() + ")");
    }

    // MM3 - can happen under force audit  
    // <node> 
    // entity.clearDirty() or entity.commited is called by transaction session 


    // okay, give it a try, move tcn up on version 
    entity.setTCN(entity.getTCN() + 1);

    int retValue = jdbcTemplate.update(String.format("UPDATE %s SET FILIALE=?, ARTIKEL=? WHERE ID=?", getCurrentTableName(session)), new PreparedStatementSetter() {
      public void setValues(PreparedStatement preparedStatement) throws SQLException {
        Acc_StockKeepingUnit acc_stockkeepingunit_2 = entity;
        int curCol = 1;

        // skipped in prepared statement dispatch 
        _stringTypeHandler.setParameter(preparedStatement, curCol++, acc_stockkeepingunit_2.getFiliale());
        _stringTypeHandler.setParameter(preparedStatement, curCol++, acc_stockkeepingunit_2.getArtikel());

        // add where query ..  
        _intTypeHandler.setParameter(preparedStatement, curCol++, acc_stockkeepingunit_2.getId());

        // TCN enabled? it was already increased by beforeUpdate..  
      }
    });

    // Dirty is cleared in transaction 

    // check retValue here 
    if (retValue != 1) {
      throw new IncorrectResultSetColumnCountException("Update statement updated " + retValue + " rows. (Entity " + entity.getClass().getName() + " with key " + entity.getKey() + ")", 1, retValue);
    }

  }





  public void insert(final Acc_StockKeepingUnit entity, final IM3ManMapSession session, boolean audit) throws DataAccessException {

    if (entity.getReadOnly()) {
      throw new IllegalStateException("Insert called on entity which was marked as readonly. (key " + entity.getKey() + ")");
    }

    if (!(entity.getDirty())) {
      throw new IllegalStateException("Insert called on entity which was not marked as dirty. (key " + entity.getKey() + ")");
    }
    // entity.clearDirty() or entity.commited is called by transaction session 



    // set keys in object 
    entity.setId(jdbcTemplate.queryForInt("SELECT S_ACC_STOCK_ENTRY.NEXTVAL FROM DUAL"));

    // run insert 
    int retValue = jdbcTemplate.update(String.format("INSERT INTO %s (ID, FILIALE, ARTIKEL) VALUES (?, ?, ?)", getCurrentTableName(session)), new PreparedStatementSetter() {
      public void setValues(PreparedStatement preparedStatement) throws SQLException {
        Acc_StockKeepingUnit acc_stockkeepingunit_2 = entity;
        int curCol = 1;

        _intTypeHandler.setParameter(preparedStatement, curCol++, acc_stockkeepingunit_2.getId());
        _stringTypeHandler.setParameter(preparedStatement, curCol++, acc_stockkeepingunit_2.getFiliale());
        _stringTypeHandler.setParameter(preparedStatement, curCol++, acc_stockkeepingunit_2.getArtikel());
      }
    });

    // Dirty is cleared in transaction 

    // check retValue here 
    if (retValue != 1) {
      throw new IncorrectResultSetColumnCountException("Insert statement updated " + retValue + " rows. (Entity " + entity.getClass().getName() + " with key " + entity.getKey() + ")", 1, retValue);
    }

    // do we have a session and a keystore?  
    if (session != null) {
      M3ObjectKeyStore<Integer, Acc_StockKeepingUnit> keyStore = session.getOrCreateKeyStore(entitySessionUID);
      keyStore.set(entity.getKey(), entity);
    }

  }





  public void delete(final Acc_StockKeepingUnit entity, final IM3ManMapSession session) throws DataAccessException {
    // should not delete readonly entities ..  
    if (entity.getReadOnly()) {
      throw new IllegalStateException("Delete called on entity which was marked as readonly. (key " + entity.getKey() + ")");
    }

    int retValue = jdbcTemplate.update(String.format("DELETE FROM %s WHERE ID = ?", getCurrentTableName(session)), new PreparedStatementSetter() {
      public void setValues(PreparedStatement preparedStatement) throws SQLException {
        Acc_StockKeepingUnit acc_stockkeepingunit_2 = entity;
        int curCol = 1;

        // add where query ..  
        _intTypeHandler.setParameter(preparedStatement, curCol++, acc_stockkeepingunit_2.getId());

      }
    });

    // check retValue here 
    if (retValue != 1) {
      throw new IncorrectResultSetColumnCountException("Delete statement updated " + retValue + " rows. (entity key " + entity.getKey() + ")", 1, retValue);
    }

    // remove object from session 
    if (session != null) {
      M3ObjectKeyStore<Integer, Acc_StockKeepingUnit> keyStore = session.getOrCreateKeyStore(entitySessionUID);
      // key ? 
      if (keyStore.has(entity.getKey())) {
        keyStore.set(entity.getKey(), null);
      }
    }

  }





  public void reload(final Acc_StockKeepingUnit entity, final IM3ManMapSession session) throws DataAccessException {
    // should not delete readonly entities ..  
    if (entity.getReadOnly()) {
      throw new IllegalStateException("reload called on entity which was marked as readonly. (key " + entity.getKey() + ")");
    }


    List<Acc_StockKeepingUnit> objects = (List<Acc_StockKeepingUnit>) jdbcTemplate.query(String.format("SELECT iRoot.ID, iRoot.FILIALE, iRoot.ARTIKEL FROM %s iRoot WHERE iRoot.ID =? ", getCurrentTableName(session)), new PreparedStatementSetter() {
      public void setValues(PreparedStatement preparedStatement) throws SQLException {
        Acc_StockKeepingUnit acc_stockkeepingunit_2 = entity;
        int curCol = 1;

        // add where query ..  
        _intTypeHandler.setParameter(preparedStatement, curCol++, acc_stockkeepingunit_2.getId());

      }
    }, new RowMapper<Acc_StockKeepingUnit>() {
      public Acc_StockKeepingUnit mapRow(ResultSet p0, int p1) throws SQLException {
        return MapAcc_StockKeepingUnit.this.map(p0, 1, entity);
      }
    });

    // check retValue here 
    if (objects.size() != 1) {
      throw new IncorrectResultSetColumnCountException("reload statement queried " + objects.size() + " rows. (entity key " + entity.getKey() + ")", 1, objects.size());
    }
  }




  public Acc_StockKeepingUnit get(final Integer outerKey, final boolean readOnly, final IM3ManMapSession session) {
    // check for 0 key 
    if (_intTypeHandler.isNullRef(outerKey)) {
      return null;
    }

    M3ObjectKeyStore<Integer, Acc_StockKeepingUnit> keyStore = null;

    // working with session 
    if (session != null) {
      keyStore = session.getOrCreateKeyStore(entitySessionUID);
      Acc_StockKeepingUnit entity = keyStore.get(outerKey);

      if (entity != null) {
        // ok, the object was found ... we are readonly 
        // the entity too - that s ok 
        if (readOnly && entity.getReadOnly()) {
          return entity;
        }

        // else ... this is a problem 
        throw new IllegalStateException("Entity " + Acc_StockKeepingUnit.class.getName() + " (key " + outerKey + ") was already checked out as r/o or r/w");
      }

    }

    // prepared statement for query ...  
    List<Acc_StockKeepingUnit> retObjects = jdbcTemplate.query(String.format("SELECT iRoot.ID, iRoot.FILIALE, iRoot.ARTIKEL FROM %s iRoot WHERE iRoot.ID =? ", getCurrentTableName(session)), new PreparedStatementSetter() {
      public void setValues(PreparedStatement preparedStatement) throws SQLException {
        int curCol = 1;
        Integer key = outerKey;


        _intTypeHandler.setParameter(preparedStatement, curCol++, key);


      }
    }, getRowMapper);


    // check retValue here 
    if (retObjects.size() != 1) {
      throw new IncorrectResultSetColumnCountException("select statement retrieved " + retObjects.size() + " rows. " + Acc_StockKeepingUnit.class.getName() + " (key " + outerKey + ")", 1, retObjects.size());
    }

    Acc_StockKeepingUnit entity = retObjects.get(0);
    if (session != null) {
      keyStore.set(outerKey, entity);
    }

    entity.clearDirtySetReadonly(readOnly);
    return entity;
  }





  public List<Acc_StockKeepingUnit> query(final String sql, ResultSetExtractor rs, final List<Object> params) {

    // instances of typehandlers are here.  
    // that s the reason for this method...  

    PreparedStatementCreator psc = new PreparedStatementCreator() {
      public PreparedStatement createPreparedStatement(Connection p0) throws SQLException {
        PreparedStatement statement = p0.prepareCall(sql);

        for (int i = 0; i < ListSequence.fromList(params).count(); i++) {
          if (ListSequence.fromList(params).getElement(i) instanceof Integer) {
            _intTypeHandler.setParameter(statement, i + 1, (Integer) ListSequence.fromList(params).getElement(i));
          } else if (ListSequence.fromList(params).getElement(i) instanceof String) {
            _stringTypeHandler.setParameter(statement, i + 1, (String) ListSequence.fromList(params).getElement(i));
          } else if (ListSequence.fromList(params).getElement(i) instanceof DateTime) {
            _dateTimeTypeHandler.setParameter(statement, i + 1, (DateTime) ListSequence.fromList(params).getElement(i));
          } else if (ListSequence.fromList(params).getElement(i) instanceof LocalDate) {
            _localDateTypeHandler.setParameter(statement, i + 1, (LocalDate) ListSequence.fromList(params).getElement(i));
          } else if (ListSequence.fromList(params).getElement(i) instanceof BigDecimal) {
            _bigDecimalTypeHandler.setParameter(statement, i + 1, (BigDecimal) ListSequence.fromList(params).getElement(i));
          } else {
            throw new IllegalArgumentException("AccountPattern.APP.MapAcc_StockKeepingUnit mapper has no typehandler for " + ListSequence.fromList(params).getElement(i) + " (arg number " + i + "). Presumably argument in query was null.");
          }
        }

        return statement;
      }
    };
    return (List<Acc_StockKeepingUnit>) jdbcTemplate.query(psc, rs);

  }
}
