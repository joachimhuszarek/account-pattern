package AccountPattern.APP;

/*Generated by MPS */

import org.modellwerkstatt.objectflow.ObjectFlowRT.IOFXProcess;
import org.apache.log4j.Logger;
import java.util.List;
import org.springframework.beans.factory.annotation.Autowired;
import org.modellwerkstatt.objectflow.ObjectFlowRT.IOFXApplicationFactory;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import java.util.ArrayList;
import org.modellwerkstatt.objectflow.ObjectFlowRT.IOFXSession;
import jetbrains.mps.internal.collections.runtime.IWhereFilter;
import org.modellwerkstatt.objectflow.ObjectFlowRT.IOFXCommand;

public class AccountProc implements IOFXProcess<Acc_StockEntry> {
  private Logger __packageLogger = Logger.getLogger("AccountPattern.APP");
  private List<String> knownCommandNames;



  @Autowired
  private IOFXApplicationFactory appFactory;


  public AccountProc() {
    // used conditions  
    // used roles  
    // commands available  
    knownCommandNames = ListSequence.fromList(new ArrayList<String>());
    ListSequence.fromList(knownCommandNames).addElement("AccountPattern.APP.Create_new_entry");

  }

  public boolean isConditionOrState(Acc_StockEntry entry, String conditionFqName) {
    // check conditions first 
    // check roles  

    // check state of process document 
    if (entry.getStatus().equals(conditionFqName)) {
      return true;
    }

    return false;
  }

  public void stateAngelegt(Acc_StockEntry entry) {
    boolean exitCommandRollback;
    // state validation first 

    // automatic evaluation of conditions -> state transitions 
  }

  public void stateFreigegeben(Acc_StockEntry entry) {
    boolean exitCommandRollback;
    // state validation first 

    // automatic evaluation of conditions -> state transitions 
  }

  public IOFXProcess.CommandPermission getCommandPermission(Acc_StockEntry entry, final String commandFqName, Object[] args) {
    IOFXProcess.CommandPermission permission = IOFXProcess.CommandPermission.DISABLED;

    // since IOFXProcess is related to IHandlesSession, a __manMapSession has  
    // to be provided, althought - not initialized (Dan Sept. 2014) 
    IOFXSession __manMapSession = null;

    // recheck state of statemachine ..  ?? 
    // No -> this is just someone asking for enabling of commands.  
    // DO NOT ADJUST STATEMEACHINE  
    // <node> 

    // creators and views do not need a procDocument 
    if ("AccountPattern.APP.Create_new_entry".equals(commandFqName)) {

      // (1) ok, command available in this process state  

      // (2) enabled condition in command ? 

      // (3) can we grant ReadOnly, default is yes 

      // (4) can we grant ReadWrite, default is yes, if not already RO given...  
      if (permission != IOFXProcess.CommandPermission.ENABLED_RO) {
        permission = IOFXProcess.CommandPermission.ENABLED_RW;
      }
      // (5) can we at least issue read only rights? 
      if (permission != IOFXProcess.CommandPermission.ENABLED_RW) {
        // did not get any rights ...  
        permission = IOFXProcess.CommandPermission.ENABLED_RO;
      }


      return permission;
    }

    // all other states following, they need the process document 
    if (entry == null) {
      return IOFXProcess.CommandPermission.DISABLED;
    }

    // check state ... and guard  
    if (entry.getStatus().equals("AN")) {

    }
    if (entry.getStatus().equals("FR")) {

    }


    // FALLBACK: just check if the command is known at all ..  
    if (!(ListSequence.fromList(knownCommandNames).any(new IWhereFilter<String>() {
      public boolean accept(String it) {
        return it.equals(commandFqName);
      }
    }))) {
      throw processException("enablecheck requested for command " + commandFqName + " -  but command unknown. (recompile?)");
    }
    return IOFXProcess.CommandPermission.DISABLED;
  }

  public IOFXProcess.CommandUiType getCommandType(final String commandFqName) {
    if ("AccountPattern.APP.Create_new_entry".equals(commandFqName)) {
      IOFXProcess.CommandUiType type = IOFXProcess.CommandUiType.PARENTSESSION_PROMPT;
      type = IOFXProcess.CommandUiType.NEWSESSION_TAB;
      return type;
    }

    // FALLBACK: just check if the command is known at all ..  
    if (!(ListSequence.fromList(knownCommandNames).any(new IWhereFilter<String>() {
      public boolean accept(String it) {
        return it.equals(commandFqName);
      }
    }))) {
      throw processException("needs new session check requested for command " + commandFqName + " -  but command unknown. (recompile?)");
    }
    return null;
  }

  public String getCommandToolTip(final String commandFqName) {
    if ("AccountPattern.APP.Create_new_entry".equals(commandFqName)) {
      return "Create new entry:\n\n";
    }

    // FALLBACK: just check if the command is known at all ..  
    if (!(ListSequence.fromList(knownCommandNames).any(new IWhereFilter<String>() {
      public boolean accept(String it) {
        return it.equals(commandFqName);
      }
    }))) {
      throw processException("tooltip requested for command " + commandFqName + " -  but command unknown. (recompile?)");
    }
    return "";
  }







  public IOFXCommand<Acc_StockEntry> startCommand(Acc_StockEntry entry, String commandFqName, Object[] args, IOFXSession parentSession) {
    IOFXCommand<Acc_StockEntry> cmd = null;
    IOFXSession session;


    IOFXProcess.CommandPermission permission = this.getCommandPermission(entry, commandFqName, args);
    if (permission == IOFXProcess.CommandPermission.DISABLED) {
      throw processException("command " + commandFqName + " can not be started in state " + ((entry == null ? "(null)" : entry.getStatus())) + " of process or enabled condition of command not fullfilled.");

    }

    if ("AccountPattern.APP.Create_new_entry".equals(commandFqName)) {
      session = appFactory.createNewSession();
      // is it a session owner? set session to readOnly, if necessary ..  
      if (permission == IOFXProcess.CommandPermission.ENABLED_RO) {
        session.setReadOnly(true);
      }
      cmd = appFactory.createNewCommand(Create_new_entry.class);
      cmd.setCommandParams(this, session, entry, args);
    }

    if (cmd == null) {
      throw processException("start of command requested, but command " + commandFqName + " is unknown. (recompile?)");
    }

    return cmd;
  }








  public void commandEnded(Acc_StockEntry entry, IOFXCommand<Acc_StockEntry> command) {
    boolean exitCommandRollback;
    // if command terminated successfully and the given process document is not null, adjust state 
    if (command.isTerminatedOk() && entry != null) {

      // change statemachine ?? do not care about status of procdoc, since these are creators and view.  

      // finally, check process ... no return happend, but command terminated in ok  
      recheckProcess(entry);
    }

  }

  public void recheckProcess(Acc_StockEntry entry) {
    if (entry != null) {
      if (entry.getStatus().equals("AN")) {
        stateAngelegt(entry);
        // do not return, since other proc auto transitions should also get  
        // evaluated ..  
      }
      if (entry.getStatus().equals("FR")) {
        stateFreigegeben(entry);
        // do not return, since other proc auto transitions should also get  
        // evaluated ..  
      }
    }
  }

  public static IllegalStateException processException(String text) {
    StringBuilder sb = new StringBuilder();
    sb.append("Process ");
    sb.append("AccountPattern.APP.AccountProc");
    sb.append(" IllegalState: ");
    sb.append(text);
    return new IllegalStateException(sb.toString());
  }
}
